<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JaydenZ&#39;s Blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-09T14:45:19.097Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JaydenZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python序列切片操作</title>
    <link href="http://yoursite.com/2018/06/09/7.Python%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/06/09/7.Python列表切片操作/</id>
    <published>2018-06-09T04:28:01.000Z</published>
    <updated>2018-06-09T14:45:19.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的序列"><a href="#Python中的序列" class="headerlink" title="Python中的序列"></a>Python中的序列</h1><p>序列(Sequence)是Python中的一种数据结构，这种数据结构根据索引来获取序列中的对象。<br>Python3中含有三种内建序列类型：list, tuple, string, range。其中range比较特殊，它是一个生成器，其他几个类型具有的一些序列特性对它并不适合，本篇不做详述。</p><h1 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h1><p>切片操作就是对序列按照给定的索引和步长，截取序列中由连续对象组成的片段。<br>对于序列结构来说，索引和步长都有正负值，分别表示左右两个方向<br><em>索引的正方向从左往右取值，起始位置为0，有效范围为 [0, 序列长度-1]</em><br><em>索引的负方向从右往左取值，起始位置为-1，有效范围为 [-序列长度, -1]</em><br>因此任意一个序列结构数据的索引范围为<code>-序列长度</code>到<code>序列长度-1</code>范围内的连续整数。</p><p>用图来表示如下，对于一个字符串’Python’，它的正负索引如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符串    P   y   t   h   o   n</span><br><span class="line">正索引    0   1   2   3   4   5</span><br><span class="line">负索引   -6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure></p><p>理解了序列索引的特点就能很轻松对字符串进行切片。</p><h2 id="切片操作语法"><a href="#切片操作语法" class="headerlink" title="切片操作语法"></a>切片操作语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sequence [start_index: end_index: step]</span><br><span class="line">    start：表示是第一个元素对象，正索引位置默认为0；负索引位置默认为 -序列长度</span><br><span class="line">    end：表示是最后一个元素对象，正索引位置默认为 序列长度－1；负索引位置默认为 -1</span><br><span class="line">    step：步长，end-start，步长为正时，从左向右取值。步长为负时，反向取值，默认为1，步长值不能为0</span><br></pre></td></tr></table></figure><p>*注意：<br>切片的结果不包含结束索引，即不包含最后的一位，-1代表列表的最后一个位置索引</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>写得再生动还不如一个例子有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#生成一组列表</span><br><span class="line">L = list(range(21))</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span><br><span class="line">&gt;&gt;&gt; len(L)</span><br><span class="line">21</span><br></pre></td></tr></table></figure></p><p>索引范围为:-21~20</p><table><thead><tr><th style="text-align:left">切片操作</th><th>含义</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:left">L[0]</td><td>取第一个元素</td><td>0</td></tr><tr><td style="text-align:left">L[:]</td><td>取一个完整的序列，相当于浅拷贝</td><td></td></tr><tr><td style="text-align:left">L[-1]</td><td>取最后一个元素</td><td>20</td></tr><tr><td style="text-align:left">L[1:5]</td><td>截取从索引为1，到索引为5前面的元素</td><td>[1, 2, 3, 4]</td></tr><tr><td style="text-align:left">L[-5:]</td><td>截取后面5个元素</td><td>[16, 17, 18, 19, 20]</td></tr><tr><td style="text-align:left">L[:10:2]</td><td>开始到索引为10的元素(但不包括)，每隔5个取一个元素</td><td>[0, 5]</td></tr><tr><td style="text-align:left">L[::5]</td><td>所有元素，每5个取一个</td><td>[0, 5, 10, 15, 20]</td></tr><tr><td style="text-align:left">L[1::5]</td><td>从索引为1的元素开始到结束，隔5个取一个元素</td><td>[1, 6, 11, 16]</td></tr><tr><td style="text-align:left">L[::-1]</td><td>将列表倒序</td><td></td></tr><tr><td style="text-align:left">L[::-4]</td><td>倒序列表后按照step的绝对值间隔取元素</td><td>[20, 16, 12, 8, 4, 0]</td></tr><tr><td style="text-align:left">L[::-3]</td><td>同上</td><td>[20, 17, 14, 11, 8, 5, 2]</td></tr><tr><td style="text-align:left">L[5:0:-1]</td><td>step为负数，逆向访问，切片访问到的正值索引范围为[1:5]</td><td>[5, 4, 3, 2, 1]</td></tr><tr><td style="text-align:left">L[1:6:-1]</td><td>step为负数，逆向访问，切片访问到的正值索引范围为[5:1]，但其中无元素</td><td>[]</td></tr></tbody></table><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://docs.python.org/3/library/stdtypes.html" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中的序列&quot;&gt;&lt;a href=&quot;#Python中的序列&quot; class=&quot;headerlink&quot; title=&quot;Python中的序列&quot;&gt;&lt;/a&gt;Python中的序列&lt;/h1&gt;&lt;p&gt;序列(Sequence)是Python中的一种数据结构，这种数据结构根据索引
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Ansible简明教程</title>
    <link href="http://yoursite.com/2018/05/12/6.Ansible%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/12/6.Ansible教程/</id>
    <published>2018-05-12T04:28:01.000Z</published>
    <updated>2018-05-18T11:13:41.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Ansible是一个简单的IT自动化管理系统，它能够实现自动化配置管理、应用程序部署、云服务管理、持续交付等功能，它是基于Python的paramiko模块实现的，使用ssh协议与Client通信，因此不需要在Client安装Agent。</p><p>Ansible有三个最吸引人的特点：</p><ul><li>无客户端</li><li>简单易用</li><li>日志集中控管</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>快速安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo esay_install ansible</span><br><span class="line">#或者</span><br><span class="line">sudo pip install ansible</span><br></pre></td></tr></table></figure></p><p>源码安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install python-docutils python2-devel python-paramiko python2-cryptography     #安装依赖</span><br><span class="line"></span><br><span class="line">git clone git://github.com/ansible/ansible.git </span><br><span class="line">cd ./ansible</span><br><span class="line">make rpm</span><br><span class="line">rpm -Uvh ./rpm-build/ansible-*.noarch.rpm</span><br><span class="line"></span><br><span class="line">mkdir -pv /etc/ansible</span><br><span class="line">cp examples/&#123;ansible.cfg,hosts&#125; /etc/ansible</span><br></pre></td></tr></table></figure></p><h1 id="Ansible组件"><a href="#Ansible组件" class="headerlink" title="Ansible组件"></a>Ansible组件</h1><h2 id="ansible命令"><a href="#ansible命令" class="headerlink" title="ansible命令"></a>ansible命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args] [options]</span><br><span class="line">    host-pattern：这次的命令对哪些主机生效，all表示对所有主机生效</span><br><span class="line">    -f forks：启动的并发线程数，一次并行处理多少主机</span><br><span class="line">    -m module_name：要使用的模块</span><br><span class="line">    -a args：模块特有的参数</span><br><span class="line">    -h：获取帮助</span><br></pre></td></tr></table></figure><h2 id="ansible配置文件"><a href="#ansible配置文件" class="headerlink" title="ansible配置文件"></a>ansible配置文件</h2><p>ansible执行的时候会按照以下顺序查找配置项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ANSIBLE_CONFIG (环境变量)</span><br><span class="line">ansible.cfg (当前目录下)</span><br><span class="line">.ansible.cfg (用户家目录下)</span><br><span class="line">/etc/ansible/ansible.cfg</span><br></pre></td></tr></table></figure></p><p>配置文件解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">action_plugins=/usr/share/ansible_plugins/action_plugins  #用于加载一些外部插件</span><br><span class="line"></span><br><span class="line">ansible_managed=Ansible managed: &#123;file&#125; modified on %Y-%m-%d %H:%M:%S by &#123;uid&#125; on &#123;host&#125; #可以在模板中插入&#123;&#123; ansible_managed &#125;&#125;来表示执行</span><br><span class="line"></span><br><span class="line">host_key_checking = False      #当主机不在known_hosts时是否提示</span><br><span class="line">ask_pass=False                 #控制Ansible playbook执行时是否会自动弹出询问密码，使用SSH 密钥匙做身份认证时需要关闭</span><br><span class="line">ask_sudo_pass=False            #控制Ansible playbook在执行sudo之前是否询问sudo密码</span><br><span class="line">executable = /bin/bash</span><br><span class="line">_forks=5</span><br><span class="line">remote_port=22                 #设置默认远程SSH端口号，不指定为22</span><br><span class="line">remote_user = root             #使用ansible playbook执行的默认用户名，不指定默认使用当前用户名称:</span><br><span class="line">roles_path = /opt/mysite/roles #路径指的是’roles/’下的额外目录,用于playbook搜索Ansible roles，多个路径可以用冒号分隔。</span><br></pre></td></tr></table></figure></p><h2 id="Inventory文件"><a href="#Inventory文件" class="headerlink" title="Inventory文件"></a>Inventory文件</h2><p>Ansible可同时操作属于一个组的多台主机,组和主机之间的关系通过Inventory 文件配置.</p><h3 id="本地Inventory文件"><a href="#本地Inventory文件" class="headerlink" title="本地Inventory文件"></a>本地Inventory文件</h3><p>默认为/etc/ansible/hosts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#配置文件格式</span><br><span class="line">mail.jaydenz.org</span><br><span class="line"></span><br><span class="line">[webservers]              #设置组名</span><br><span class="line">web1.jaydenz.org:8080     #可指明端口号</span><br><span class="line">web2.jaydenz.org</span><br><span class="line">web[3:10].jaydenz.org</span><br><span class="line"></span><br><span class="line">[dbservers]</span><br><span class="line">db1.jaydenz.org    ansible_connection=ssh    ansible_ssh_user=jaydenz    #对于单个链接可以设置连接类型和用户名    </span><br><span class="line">db2.jaydenz.org</span><br><span class="line"></span><br><span class="line">#通过jumper关键字设置别名</span><br><span class="line">jumper ansible_ssh_port=5555 ansible_ssh_host=192.168.1.50     #会连接 192.168.1.50:5555</span><br><span class="line"></span><br><span class="line">#其他参数说明</span><br><span class="line">ansible_ssh_host              #将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class="line">ansible_ssh_port              #ssh端口号.如果不是默认的端口号,通过此变量设置.</span><br><span class="line">ansible_ssh_user              #默认的 ssh 用户名</span><br><span class="line">ansible_ssh_pass              #ssh密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class="line">ansible_sudo_pass             #sudo密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class="line">ansible_sudo_exe              #sudo命令路径(适用于1.8及以上版本)</span><br><span class="line">ansible_connection            #与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.</span><br><span class="line">ansible_ssh_private_key_file  #ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class="line">ansible_shell_type            #目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.</span><br><span class="line">ansible_python_interpreter    #目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python；不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26)；与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure></p><h3 id="远程Inventory文件"><a href="#远程Inventory文件" class="headerlink" title="远程Inventory文件"></a>远程Inventory文件</h3><p>Ansible支持使用其他软件系统保存Inventory配置信息</p><ul><li>从云端拉取 inventory</li><li>LDAP（Lightweight Directory Access Protocol,轻量级目录访问协议）</li><li>Cobbler <a href="http://cobbler.github.com" target="_blank" rel="noopener">http://cobbler.github.com</a></li><li>CMDB（配置管理数据库）软件<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="查看模块说明"><a href="#查看模块说明" class="headerlink" title="查看模块说明"></a>查看模块说明</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc [options] [modules]     #查看模块信息</span><br><span class="line">    options：</span><br><span class="line">        -l     #列出所有的ansible模块</span><br><span class="line">        -s     #列出该模块的相关指令</span><br></pre></td></tr></table></figure><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="调试和测试类的module"><a href="#调试和测试类的module" class="headerlink" title="调试和测试类的module"></a>调试和测试类的module</h4><ul><li><p>ping：最常用的测试一个节点有没有配置好ssh连接的module，如果可以通过ansible成功连接，那么返回pong，使用时不需要传入参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible servers -m ping</span><br></pre></td></tr></table></figure></li><li><p>debug：用于调试的module，只是简单打印一些消息，有点像linux的echo命令。</p></li></ul><p>通过参数msg定义打印的字符串，msg中可以嵌入变量,下面的例子中注入了系统变量，ansible在执行Playbook之前会收集一些比较常用的系统变量，在Playbook中不需要定义直接就可以使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- debug:</span><br><span class="line">    msg: &quot;System &#123;&#123; inventory_hostname &#125;&#125; has gateway &#123;&#123; ansible_default_ipv4.gateway &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>通过参数var定义需要打印的变量，变量可以是系统变量，也可以是动态的执行结果，通过关键字regester注入到变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: Display all variables/facts known for a host</span><br><span class="line">  debug:</span><br><span class="line">     var: hostvars[inventory_hostname][&quot;ansible_default_ipv4&quot;][&quot;gateway&quot;]</span><br></pre></td></tr></table></figure></p><p>通过Ad Hoc Command执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m debug -a &apos;msg=&#123;&#123; inventory_hostname &#125;&#125;&apos;</span><br></pre></td></tr></table></figure></p><ul><li>setup：收集远程主机的facts。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m setup</span><br></pre></td></tr></table></figure></li></ul><p>引用收集到的Facts信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#可以在playbook中这样引用第一个硬盘的模型:</span><br><span class="line">    &#123;&#123; ansible_devices.sda.model &#125;&#125;</span><br><span class="line">#同样,作为系统报告的主机名如以下所示:</span><br><span class="line">    &#123;&#123; ansible_nodename &#125;&#125;</span><br><span class="line">#不合格的主机名显示了句号(.)之前的字符串:</span><br><span class="line">    &#123;&#123; ansible_hostname &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>关闭fact<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- hosts: whatever</span><br><span class="line">  gather_facts: no</span><br></pre></td></tr></table></figure></p><h4 id="文件类的module"><a href="#文件类的module" class="headerlink" title="文件类的module"></a>文件类的module</h4><ul><li>copy：从本地拷贝文件到远程节点</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mode：</span><br><span class="line">backup：参数为yes的时候，如果发生了拷贝操作，那么会先备份目标节点上的原文件</span><br><span class="line">checksum：</span><br><span class="line">src：源地址。如果路径以/结尾，则只复制路径中的内容；不以/结尾，该目录及其内部内容都会被复制</span><br><span class="line">remote_src：当mode=preserve有效，</span><br><span class="line">dest：复制的目的路径。当src指定为一个目录时，dest也必须为目录；当dest以/结尾或路径不存在时或者src是一个目录时，dest指明的路径将被创建；当src和dest都是文件时，dest的父目录不存在将不会被创建，任务将会失败</span><br><span class="line">content：</span><br><span class="line">follow：</span><br><span class="line">validate：验证文件的命令。一般需要验证拷贝后的文件，所以%s可以指代拷贝后的文件。只有复制和验证都完成才算执行成功</span><br><span class="line">force：为yes时将会覆盖与源路径不同的目的内容，为no时仅会传输远程目的路径不存在的内容，默认为yes</span><br><span class="line">owner：类似于chown命令，改变所属主</span><br><span class="line">group：类似于chown命令，改变所属组</span><br><span class="line">mode：设置文件权限。mode设置权限可以是用数字，也可以是符号的形式”u=rw,g=r,o=r”和”u+rw,g-wx,o-rwx”</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- copy:</span><br><span class="line">    src: /mine/sudoers</span><br><span class="line">    dest: /etc/sudoers</span><br><span class="line">    validate: &apos;visudo -cf %s&apos;  #visudo -cf /etc/sudoers是验证sudoers文件有没有语法错误的命令。</span><br></pre></td></tr></table></figure></p><ul><li>template：拷贝一个文件，并且根据需要调整部分内容。</li></ul><p>指定替换个部分用变量来表示，template使用的是python的j2模版引擎，变量的表示法是<code></code></p><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backup：建立包含时间戳的备份，默认为no</span><br><span class="line">src：本地Jinjia2模版的template文件位置</span><br><span class="line">dest：远程节点上的绝对路径，用于放置template文件</span><br><span class="line">owner：设置文件或目录所属主</span><br><span class="line">group：设置文件或目录所属组</span><br><span class="line">mode：设置远程节点上的template文件权限。类似Linux中chmod的用法</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- template:</span><br><span class="line">    src: /mytemplates/foo.j2</span><br><span class="line">    dest: /etc/file.conf</span><br><span class="line">    owner: bin</span><br><span class="line">    group: wheel</span><br><span class="line">    mode: 0644</span><br><span class="line"></span><br><span class="line">- template:</span><br><span class="line">    src: config.ini.j2</span><br><span class="line">    dest: /share/windows/config.ini</span><br><span class="line">    newline_sequence: &apos;\r\n&apos;</span><br><span class="line"></span><br><span class="line">- template:</span><br><span class="line">    src: /mine/sudoers</span><br><span class="line">    dest: /etc/sudoers</span><br><span class="line">    validate: &apos;/usr/sbin/visudo -cf %s&apos;     #验证配置文件是否正确</span><br></pre></td></tr></table></figure></p><ul><li>file：设置文件的属性</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">attributes：改变文件、目录属性，相当于chattr命令</span><br><span class="line">follow：如果原来的文件是link，拷贝后是否依旧是link，默认为yes</span><br><span class="line">force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，默认为no</span><br><span class="line">state：参数：</span><br><span class="line">   directory：如果目录不存在，创建目录</span><br><span class="line">   file：即使文件不存在，也不会被创建，默认参数</span><br><span class="line">   link：创建软链接</span><br><span class="line">   hard：创建硬链接</span><br><span class="line">   touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</span><br><span class="line">   absent：删除目录、文件或者取消链接文件</span><br><span class="line">src：要被链接的源文件的路径，只应用于state=link的情况</span><br><span class="line">dest：当state=link时，表示创建的指向src的链接文件放置路径</span><br><span class="line">path：需要管理的文件路径</span><br><span class="line">recurse：递归的设置文件的属性，只对目录有效</span><br><span class="line">owner：设置文件或目录所属主</span><br><span class="line">group：设置文件或目录所属组</span><br><span class="line">mode：设置远程节点上的文件权限。类似Linux中chmod的用法</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- file:</span><br><span class="line">    path: /etc/foo.conf</span><br><span class="line">    owner: foo</span><br><span class="line">    group: foo</span><br><span class="line">    mode: 0644</span><br><span class="line">- file:</span><br><span class="line">    src: /file/to/link/to</span><br><span class="line">    dest: /path/to/symlink</span><br><span class="line">    owner: foo</span><br><span class="line">    group: foo</span><br><span class="line">    state: link</span><br><span class="line">- file:</span><br><span class="line">    src: &apos;/tmp/&#123;&#123; item.src &#125;&#125;&apos;</span><br><span class="line">    dest: &apos;&#123;&#123; item.dest &#125;&#125;&apos;</span><br><span class="line">    state: link</span><br><span class="line">  with_items:</span><br><span class="line">    - &#123; src: &apos;x&apos;, dest: &apos;y&apos; &#125;</span><br><span class="line">    - &#123; src: &apos;z&apos;, dest: &apos;k&apos; &#125;</span><br></pre></td></tr></table></figure></p><h4 id="linux上常用的操作"><a href="#linux上常用的操作" class="headerlink" title="linux上常用的操作"></a>linux上常用的操作</h4><ul><li>user：管理用户账户</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">state：present表示添加用户，absent表示删除用户</span><br><span class="line">name：用户名</span><br><span class="line">create_home：是否创建家目录，默认为yes</span><br><span class="line">home：用于设定家目录路径</span><br><span class="line">uid：用户的uid</span><br><span class="line">group：所属组，即私有组</span><br><span class="line">groups：附加组</span><br><span class="line">password：设置用户密码(加密过后的值)</span><br><span class="line">remove：当state=absent时使用，等同于userdel --remove，删除用户并删除家目录及其文件</span><br><span class="line">shell：设置用户所使用的shell</span><br><span class="line">system：创建一个用户时是否加入管理员组，对已存在用户无效</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible mysql -m user -a &apos;name=&quot;mysql&quot; group=&quot;mysql&quot; create_home=no shell=&quot;/sbin/nologin&quot;&apos;</span><br><span class="line">ansible mysql -a &apos;cat /etc/passwd&apos; | grep mysql       #查看是否添加成功</span><br><span class="line">ansible mysql -m user -a &apos;state=absent name=&quot;mysql&quot;&apos;  #删除用户</span><br></pre></td></tr></table></figure></p><ul><li>yum：Red Hat系linux上的包管理，同样还有支持Debian系的apt模块</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state：present表示安装，latest表示升级最新版，absent表示删除</span><br><span class="line">name：指明包名</span><br><span class="line">list：指定不同参数列出相应信息：packages, installed, updates, available, repos</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m yum -a &apos;list=installed&apos;</span><br></pre></td></tr></table></figure></p><ul><li>service：管理服务</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">state：包含多个选项：reloaded, restarted, running, started, stopped</span><br><span class="line">arguments：</span><br><span class="line">enable：是否开机启动</span><br><span class="line">name：服务名</span><br><span class="line">pattern：</span><br><span class="line">runlevel：</span><br><span class="line">sleep：</span><br></pre></td></tr></table></figure></p><ul><li>cron：可以让每一个被管理节点能够自动生成一个定期任务计划，生成的任务文件在/var/spool/cron/对应的用户名文件中</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state：present表示添加crontab任务；absent表示移除crontab任务</span><br><span class="line">job：指明运行的命令是什么</span><br><span class="line">name：crontab任务的名字</span><br><span class="line">minute：指明分钟周期，未指明默认为*</span><br><span class="line">day：指明天周期，未指明默认为*</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible mysql -m cron -a &apos;state=present minute=&quot;*/10&quot; job=&quot;/usr/bin/echo hello&quot; name=&quot;test cron job&quot;&apos;</span><br><span class="line">ansible mysql -a &apos;crontab -l&apos;                   #查看是否成功添加</span><br><span class="line">ansible mysql -a &apos;cat /var/spool/cron/root&apos;     #查看生成的文件</span><br></pre></td></tr></table></figure></p><h4 id="执行Shell命令"><a href="#执行Shell命令" class="headerlink" title="执行Shell命令"></a>执行Shell命令</h4><ul><li>shell：在节点上执行shell命令，支持$HOME和”&lt;”, “&gt;”, “|”, “;” and “&amp;”，用于执行复杂命令</li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chdir：运行命令前进入指定的目录</span><br><span class="line">creates：创建一个文件，如果已存在则不会运行此步骤</span><br><span class="line">executable：更改用于执行命令的Shell，必须使用绝对路径</span><br><span class="line">removes：删除一个文件，如果不存在则不会进行</span><br><span class="line">stdin：设置执行的命令的stdin为一个特定来源</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: </span><br><span class="line">  shell: somescript.sh &gt;&gt; somelog.txt     #重定向输出</span><br><span class="line">  args:</span><br><span class="line">    chdir: somedir/                       #改变目录</span><br><span class="line">    creates: somelog.txt                  #当somelog.txt不存在时创建它</span><br></pre></td></tr></table></figure></p><ul><li><p>command：在远程节点上面执行命令，不支持$HOME和”&lt;”, “&gt;”, “|”, “;” and “&amp;”<br>默认的模块，表示在被管理主机上运行一个命令。对于command模块，-a不再是指定参数，而是命令本身,所以该模块无法传递参数或变量<br>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m command -a &quot;date&quot;</span><br></pre></td></tr></table></figure></li><li><p>script：将本地脚本复制到远程主机并运行</p></li></ul><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chdir：运行命令前进入指定的目录</span><br><span class="line">creates：创建一个文件，如果已存在则不会运行此步骤</span><br><span class="line">removes：删除一个文件，如果不存在则不会进行</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- script: /some/local/script.sh --some-arguments 1234</span><br><span class="line">  args:</span><br><span class="line">    creates: /the/created/file.txt</span><br></pre></td></tr></table></figure></p><ul><li>template：从本地拷贝文件到远程节点，并进行变量替换</li></ul><p>ansbile在管理每一个主机时，这些主机在被运行管理命令之前，会首先向ansible节点报告自己主机当前的各种可能被ansible主机用到的状态信息，如操作系统版本、ip地址等信息，这些信息都是以变量的形式，ansible主机可以在jinjia2中调用，为不同的服务器生成不同的配置文件。</p><p>参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backup：是否生成一个包含时间戳的备份</span><br><span class="line">src：指明本地j2模板文件地址</span><br><span class="line">dest：指明远程主机应用配置文件的路径</span><br><span class="line">mode：设置文件权限</span><br><span class="line">validate：验证配置文件是否正确</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- template:</span><br><span class="line">    src: /mytemplates/foo.j2</span><br><span class="line">    dest: /etc/file.conf</span><br><span class="line">    owner: bin</span><br><span class="line">    group: wheel</span><br><span class="line">    mode: 0644</span><br><span class="line">#配置sudoers文件并验证是否正确</span><br><span class="line">- template:</span><br><span class="line">    src: /mine/sudoers</span><br><span class="line">    dest: /etc/sudoers</span><br><span class="line">    validate: &apos;/usr/sbin/visudo -cf %s&apos;</span><br><span class="line">#配置sshd并验证配置文件是否正确</span><br><span class="line">- template:</span><br><span class="line">    src: etc/ssh/sshd_config.j2</span><br><span class="line">    dest: /etc/ssh/sshd_config</span><br><span class="line">    owner: root</span><br><span class="line">    group: root</span><br><span class="line">    mode: &apos;0600&apos;</span><br><span class="line">    validate: /usr/sbin/sshd -t -f %s</span><br><span class="line">    backup: yes</span><br></pre></td></tr></table></figure></p><h2 id="Ad-Hoc-Commands"><a href="#Ad-Hoc-Commands" class="headerlink" title="Ad Hoc Commands"></a>Ad Hoc Commands</h2><p>Ansible提供的命令行工具，用于在ansible中快速执行，并且不需要保存的命令。</p><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m setup             #查看远程主机facts</span><br><span class="line">ansible all -m ping -u jaydenz   #检查所有的远程主机，是否以jaydenz用户创建了ansible主机可以访问的环境。</span><br><span class="line">ansible all -a &quot;/bin/echo hello&quot; #在所有的远程主机上，以当前bash的同名用户，在远程主机执行“echo hello”</span><br><span class="line">ansible web -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot; #拷贝文件/etc/host到远程主机（组）web，位置为/tmp/hosts</span><br><span class="line">ansible web -m git -a &quot;repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD&quot; #git一个项目到web主机本地目录</span><br></pre></td></tr></table></figure></p><h2 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h2><p>Playbook是由一个或多个play组成的列表，针对每一组server的所有操作就组成一个play。Playbook的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。在写Playbook的时候，一定要记住在hosts、模块名等后面带空格，否则会报错。<br>执行Playbook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook deploy.yml</span><br></pre></td></tr></table></figure></p><p>在运行Playbook的时候也可以传递一些变量供Playbook使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook test.yml --extra-vars &quot;hosts=mysql user=jaydenz&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Playbook关键字"><a href="#Playbook关键字" class="headerlink" title="Playbook关键字"></a>Playbook关键字</h3><ul><li><p>hosts和remote_users</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- hosts: mysql       #指明执行任务的主机，可以是一个或多个由冒号分隔主机组</span><br><span class="line">  remote_user: root  #指定远程主机上执行任务的用户</span><br><span class="line">  tasks:             #建立一个任务列表</span><br><span class="line">    - name: Test To Connect MySQL Server #任务名</span><br><span class="line">      ping:</span><br><span class="line">      remote_user: root                  #在tasks中也可以定义执行的用户身份</span><br><span class="line">      sudo: yes                          #指定使用sudo方式运行</span><br><span class="line">      sudo_user: jaydenz                 #指定sudo时切换的用户</span><br></pre></td></tr></table></figure></li><li><p>tasks：任务，调用模块完成某操作</p></li></ul><p>Playbook的核心，定义按顺序执行的动作action，每个action调用一个ansbile module，如果中途发生错误所有任务将会回滚。每个Task都需要使用- name指定一个名用于Playbook的执行结果输出，如果未提供name，则Action的结果将用于输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line"> - name: make sure apache is running</span><br><span class="line">   service: name=httpd state=running   #定义一个Action，建议使用module：module_parameter=module_value格式的语法</span><br><span class="line">   #如果action一行的内容过多，也中使用在行首使用几个空白字符进行换行。</span><br></pre></td></tr></table></figure></p><p>在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">    - name: disable selinux</span><br><span class="line">      command: /sbin/setenforce 0</span><br></pre></td></tr></table></figure></p><p>如果命令或脚本的退出码不为零，可以使用如下方式替代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">   - name: run this command and ignore the result</span><br><span class="line">     shell: /usr/bin/somecommand || /bin/true</span><br></pre></td></tr></table></figure></p><p>或者使用ignore_errors来忽略错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: /usr/bin/somecommand    </span><br><span class="line">    ignore_errors: True</span><br></pre></td></tr></table></figure></p><ul><li><p>vars</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- hosts: webservers</span><br><span class="line">  vars:</span><br><span class="line">    package: httpd     #定义一个变量</span><br><span class="line">    service: httpd     </span><br><span class="line">  tasks:</span><br><span class="line">  - name: install httpd package</span><br><span class="line">    yum: name=&#123;&#123; package &#125;&#125; state=latest    #引用package变量</span><br><span class="line"></span><br><span class="line">#注意：</span><br><span class="line">- hosts: app_servers</span><br><span class="line">vars:</span><br><span class="line">   app_path: &quot;&#123;&#123; base_path &#125;&#125;/22&quot;    #YAML语法要求如果值以&#123;&#123; foo &#125;&#125;开头的话我们需要将整行用双引号包起来</span><br></pre></td></tr></table></figure></li><li><p>register</p></li></ul><p>把任务的输出定义为变量，然后用于其他任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - shell: /usr/bin/foo</span><br><span class="line">    register: foo_result     #把shell的输出赋值给foo_result</span><br><span class="line">    ignore_errors: True</span><br></pre></td></tr></table></figure></p><ul><li>when</li></ul><p>在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: &quot;shutdown Debian flavored systems&quot;</span><br><span class="line">    command: /sbin/shutdown -h now</span><br><span class="line">    when: ansible_os_family == &quot;Debian&quot;</span><br></pre></td></tr></table></figure></p><p>when语句中还可以使用Jinja2的大多“filter”，例如要忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句，可使用类似如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - command: /bin/false</span><br><span class="line">    register: result</span><br><span class="line">    ignore_errors: True</span><br><span class="line">  - command: /bin/something</span><br><span class="line">    when: result|failed</span><br><span class="line">  - command: /bin/something_else</span><br><span class="line">    when: result|success</span><br><span class="line">  - command: /bin/still/something_else</span><br><span class="line">    when: result|skipped</span><br></pre></td></tr></table></figure></p><p>此外，when语句中还可以使用facts或playbook中定义的变量。</p><ul><li>handlers</li></ul><p>用于当监控的资源发生变化时采取一定的操作。使用handlers定义一个或一组action，每个action使用name关键字指明名称，在要监控的资源处定义notify并指明需要调用的handlers的名称，handlers也属于tasks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">    max_clients: 200</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: ensure apache is at the latest version</span><br><span class="line">    yum: pkg=httpd state=latest</span><br><span class="line"></span><br><span class="line">  - name: Write the configuration file</span><br><span class="line">    template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">    notify:           #定义一个notify监控配置文件是否发送改变</span><br><span class="line">    - restart apache  #调用handlers中名称为restart apache的action</span><br><span class="line"></span><br><span class="line">  - name: Write the default index.html file</span><br><span class="line">    template: src=templates/index.html.j2 dest=/var/www/html/index.html</span><br><span class="line"></span><br><span class="line">  - name: ensure apache is running</span><br><span class="line">    service: name=httpd state=started</span><br><span class="line">    </span><br><span class="line">  handlers:                 #定义一个handlers</span><br><span class="line">    - name: restart apache  #定义一个处理动作</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">    - name: ping server</span><br><span class="line">      ping:</span><br></pre></td></tr></table></figure></p><ul><li>roles</li></ul><p>ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p><p>一个项目的目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">site.yml</span><br><span class="line">webservers.yml</span><br><span class="line">fooservers.yml</span><br><span class="line">roles/</span><br><span class="line">   common/     #定义一个名为common的role</span><br><span class="line">     files/</span><br><span class="line">     templates/</span><br><span class="line">     tasks/</span><br><span class="line">     handlers/</span><br><span class="line">     vars/</span><br><span class="line">     defaults/</span><br><span class="line">     meta/</span><br><span class="line">   webservers/</span><br><span class="line">     files/</span><br><span class="line">     templates/</span><br><span class="line">     tasks/</span><br><span class="line">     handlers/</span><br><span class="line">     vars/</span><br><span class="line">     defaults/</span><br><span class="line">     meta/</span><br></pre></td></tr></table></figure></p><p>该项目的一个playbook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- hosts: webservers</span><br><span class="line">  roles: </span><br><span class="line">      - common     #使用名为common的role</span><br><span class="line">      - webservers</span><br><span class="line">      </span><br><span class="line">这个playbook 为一个角色 ‘x’ 指定了如下的行为：</span><br><span class="line">    如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中</span><br><span class="line">    如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中</span><br><span class="line">    如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中</span><br><span class="line">    如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)</span><br><span class="line">    </span><br><span class="line">    所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。</span><br><span class="line">    所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。</span><br><span class="line">    所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。</span><br><span class="line">    所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。</span><br><span class="line">    在 Ansible 1.4 及之后版本，你可以为”角色”的搜索设定 roles_path 配置项。使用这个配置项将所有的 common 角色 check out 到一个位置，以便在多个 playbook 项目中可方便的共享使用它们。</span><br><span class="line">    </span><br><span class="line">#可以使用参数化的 roles，这种方式通过添加变量来实现</span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - common</span><br><span class="line">    - &#123; role: foo_app_instance, dir: &apos;/opt/a&apos;,  port: 5000 &#125;</span><br><span class="line">    - &#123; role: foo_app_instance, dir: &apos;/opt/b&apos;,  port: 5001 &#125;</span><br><span class="line">    - &#123; role: some_role, when: &quot;ansible_os_family == &apos;RedHat&apos;&quot; &#125;  #为roles设置触发条件</span><br><span class="line">    - &#123; role: foo, tags: [&quot;bar&quot;, &quot;baz&quot;] &#125;      #给roles分配指定的tags</span><br><span class="line">      #注意:role、dir、port是变量名，冒号后面的是变量值。</span><br><span class="line">#定义一些 tasks，让它们在 roles 之前以及之后执行，如果对tasks应用了tags，需确保给pre_tasks以及post_tasks也同样应用 tags，并且将它们一并传递。</span><br><span class="line">- hosts: webservers</span><br><span class="line">  pre_tasks:</span><br><span class="line">    - shell: echo &apos;hello&apos;</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: some_role &#125;</span><br><span class="line">  tasks:</span><br><span class="line">    - shell: echo &apos;still busy&apos;</span><br><span class="line">  post_tasks:</span><br><span class="line">    - shell: echo &apos;goodbye&apos;</span><br></pre></td></tr></table></figure></p><p>角色依赖：可以自动地将其他roles拉取到现在使用的role中，保存在roles目录下的 meta/main.yml 文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#roles/myapp/meta/main.yml示例</span><br><span class="line">dependencies:</span><br><span class="line">  - &#123; role: common, some_parameter: 3 &#125;</span><br><span class="line">  - &#123; role: apache, port: 80 &#125;</span><br><span class="line">  - &#123; role: postgres, dbname: blarg, other_parameter: 12 &#125;</span><br><span class="line">#角色依赖可以通过绝对路径指定，如同顶级角色的设置:</span><br><span class="line">dependencies:</span><br><span class="line">   - &#123; role: &apos;/path/to/common/roles/foo&apos;, x: 1 &#125;</span><br><span class="line"></span><br><span class="line">#角色依赖总是在role（包含角色依赖的role）之前执行，并且是递归地执行。默认情况下，作为角色依赖被添加的role只能被添加一次，如果另一个 role 将一个相同的角色列为角色依赖的对象，它不会被重复执行。</span><br><span class="line">#但这种默认的行为可被修改，通过添加 allow_duplicates: yes 到 meta/main.yml 文件中。 比如，一个role名为car，它可以添加名为wheel的 role到它的角色依赖中:</span><br><span class="line">    dependencies:</span><br><span class="line">    - &#123; role: wheel, n: 1 &#125;</span><br><span class="line">    - &#123; role: wheel, n: 2 &#125;</span><br><span class="line">    - &#123; role: wheel, n: 3 &#125;</span><br><span class="line">    - &#123; role: wheel, n: 4 &#125;</span><br><span class="line">wheel角色的 meta/main.yml 文件包含如下内容:</span><br><span class="line">    allow_duplicates: yes</span><br><span class="line">    dependencies:</span><br><span class="line">    - &#123; role: tire &#125;</span><br><span class="line">    - &#123; role: brake &#125;</span><br><span class="line">最终的执行顺序是这样的:</span><br><span class="line">    tire(n=1)</span><br><span class="line">    brake(n=1)</span><br><span class="line">    wheel(n=1)</span><br><span class="line">    tire(n=2)</span><br><span class="line">    brake(n=2)</span><br><span class="line">    wheel(n=2)</span><br><span class="line">    ...</span><br><span class="line">    car</span><br></pre></td></tr></table></figure></p><ul><li>tags：用于让用户选择运行或跳过Playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">- name:</span><br><span class="line">  tags:</span><br><span class="line">  - conf</span><br><span class="line">  </span><br><span class="line"># ansible-playbook apache.yml --tages=&apos;conf&apos;    #仅运行tages为conf的任务</span><br></pre></td></tr></table></figure></li></ul><p>特殊tags: always，</p><ul><li>迭代</li></ul><p>当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: add several users</span><br><span class="line">  user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel</span><br><span class="line">  with_items:</span><br><span class="line">     - testuser1</span><br><span class="line">     - testuser2</span><br></pre></td></tr></table></figure></p><p>上面语句的功能等同于下面的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: add user testuser1</span><br><span class="line">  user: name=testuser1 state=present groups=wheel</span><br><span class="line">- name: add user testuser2</span><br><span class="line">  user: name=testuser2 state=present groups=wheel</span><br></pre></td></tr></table></figure></p><p>注意：with_items中的列表值也可以是字典, 但引用时要使用item.KEY</p><ul><li>include：用于引用其他文件中的tasks，可以将配置策略分解到更小的文件中，实现配置重用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - include: tasks/foo.yml</span><br><span class="line">  - include: wordpress.yml wp_user=timmy</span><br><span class="line"></span><br><span class="line">#在1.4版本开始可以支持的语法</span><br><span class="line">- &#123; include: wordpress.yml, wp_user: timmy, ssh_keys: [ &apos;keys/one.txt&apos;, &apos;keys/two.txt&apos; ] &#125;</span><br><span class="line"></span><br><span class="line">#1.0版本开始支持传递变量到include files</span><br><span class="line">- include: wordpress.yml</span><br><span class="line">vars:</span><br><span class="line">    wp_user: timmy     #在文件中使用&#123;&#123; wp_user &#125;&#125;来定义变量</span><br><span class="line">    some_list_variable:</span><br><span class="line">      - alpha</span><br><span class="line">      - beta</span><br><span class="line">      - gamma</span><br><span class="line">      </span><br><span class="line">#Include 语句可以和其他非 include 的 tasks 和 handlers 混合使用</span><br><span class="line">handlers:</span><br><span class="line">- include: handlers/handlers.yml</span><br><span class="line"></span><br><span class="line">#Include 语句也可用来将一个 playbook 文件导入另一个 playbook 文件。这种方式允许你定义一个 顶层的 playbook，这个顶层 playbook 由其他 playbook 所组成，但是在playbook中引用其他playbook时，不能使用变量替换。</span><br><span class="line">- name: this is a play at the top level of a file</span><br><span class="line">hosts: all</span><br><span class="line">remote_user: root</span><br><span class="line"></span><br><span class="line">tasks:</span><br><span class="line"></span><br><span class="line">- name: say hi</span><br><span class="line">  tags: foo</span><br><span class="line">  shell: echo &quot;hi...&quot;</span><br><span class="line"></span><br><span class="line">- include: load_balancers.yml     #导入其他playbook</span><br><span class="line">- include: webservers.yml</span><br><span class="line">- include: dbservers.yml</span><br></pre></td></tr></table></figure></li></ul><h1 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h1><ol><li>安装ansible</li><li>首先在/etc/ansible/hosts定义主机清单</li><li><p>配置生成密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &apos;&apos;</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.213.10</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.213.20</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.213.30</span><br></pre></td></tr></table></figure></li><li><p>测试连通性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure></li><li><p>执行Playbook</p></li></ol><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="PIP未安装"><a href="#PIP未安装" class="headerlink" title="PIP未安装"></a>PIP未安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install python-pip</span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><h2 id="执行ansible提示’you-must-install-the-sshpass-program’"><a href="#执行ansible提示’you-must-install-the-sshpass-program’" class="headerlink" title="执行ansible提示’you must install the sshpass program’"></a>执行ansible提示’you must install the sshpass program’</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在extras源中</span><br><span class="line">yum install sshpass</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>中文文档：<a href="https://getansible.com/" target="_blank" rel="noopener">https://getansible.com/</a></p><p>Ansible官方模块说明：<a href="http://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html</a></p><p>个人常用Playbook：<a href="https://github.com/Jaydenz/playbook" target="_blank" rel="noopener">https://github.com/Jaydenz/playbook</a></p><p>Playbook指南：<a href="http://ansible-tran.readthedocs.io/en/latest/docs/playbooks.html" target="_blank" rel="noopener">http://ansible-tran.readthedocs.io/en/latest/docs/playbooks.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Ansible是一个简单的IT自动化管理系统，它能够实现自动化配置管理、应用程序部署、云服务管理、持续交付等功能，它是基于Python的pa
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="自动化" scheme="http://yoursite.com/categories/Linux/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://yoursite.com/categories/Linux/%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PXE与Kickstart配置</title>
    <link href="http://yoursite.com/2018/05/07/5.PXE%E4%B8%8EKickstart%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/07/5.PXE与Kickstart配置/</id>
    <published>2018-05-07T04:28:01.000Z</published>
    <updated>2018-05-07T14:54:30.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>预启动执行环境(Preboot eXecute Environment，PXE)，<br>该技术基于C/S构架，提供了一种使用网络接口(Network Interface)启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备(如硬盘)或本地已安装的操作系统。PXE技术通常用于自动部署操作系统，通过读取Kickstart文件中的配置可以实现无人值守安装。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>PXE技术依赖于DHCP、TFTP、File Server</p><ul><li>DHCP服务用于在新主机上线时提供IP地址，更重要的是指定提供PXE启动文件的服务器IP地址。</li><li>TFTP服务用于提供PXE启动文件。</li><li>File Server则用来提供Kickstart配置文件和Linux的安装源文件。<h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2></li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>CentOS 7 Server 1台</p><ul><li>内网IP：192.168.213.5/24</li><li>外网IP：192.168.1.134/24</li><li>域：jaydenz.org</li><li>防火墙：开启</li><li>SELinux：开启</li></ul><p>支持PXE技术的Client 2台</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="Server端："><a href="#Server端：" class="headerlink" title="Server端："></a>Server端：</h4><ol><li><p>安装相关服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install dhcp tftp-server syslinux vsftpd</span><br></pre></td></tr></table></figure></li><li><p>配置DHCP服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/dhcp/dhcp.conf</span><br><span class="line"></span><br><span class="line">ddns-update-style interim;  #设置dhcp互动更新模式</span><br><span class="line">ignore client-updates;     #ddns忽略客户端更新authoritative;</span><br><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">allow unknown-clients;</span><br><span class="line">#设定DHCP-Server生效的网段</span><br><span class="line">subnet 192.168.213.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 192.168.213.40 192.168.213.200;         #设定地址池范围</span><br><span class="line">##地址池选项</span><br><span class="line">    option domain-name-servers 114.114.114.114;   #设定DNS服务器IP</span><br><span class="line">    option domain-name &quot;jaydenz.org&quot;;             #设定域</span><br><span class="line">    option routers 192.168.213.5;                 #设定路由器IP</span><br><span class="line">    option broadcast-address 192.168.213.255;</span><br><span class="line">##租约时间设定</span><br><span class="line">    default-lease-time 86400;                       </span><br><span class="line">    max-lease-time 86400;</span><br><span class="line">    ##设置PXE服务</span><br><span class="line">    next-server 192.168.213.5; #DHCP server ip</span><br><span class="line">    filename &quot;pxelinux.0&quot;;                        #指定pxe文件，默认在TFTP服务器共享目录</span><br><span class="line">    ##设置一份地址白名单，用于排除该地址</span><br><span class="line">    host MacbookPro &#123;</span><br><span class="line">        hardware ethernet 00:0C:29:05:A7:CB; </span><br><span class="line">        fixed-address 192.168.213.110; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subnet 192.168.1.0 netmask 255.255.255.224 &#123;      #建立一个空的配置关闭对外网的地址分配功能</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改TFTP服务启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/tftp.service</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/sbin/in.tftpd -s /tftpboot  ##修改tftp工作目录</span><br></pre></td></tr></table></figure></li><li><p>建立tftpboot目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tftpboot</span><br></pre></td></tr></table></figure></li><li><p>修改SELinux设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t public_content_t &quot;/tftpboot(/.*)?&quot;</span><br><span class="line">restorecon -F -R -v /tftpboot</span><br></pre></td></tr></table></figure></li><li><p>复制syslinux文件到启动目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/syslinux/</span><br><span class="line">cp pxelinux.0 menu.c32 memdisk mboot.c32 chain.c32 /tftpboot/</span><br></pre></td></tr></table></figure></li><li><p>修改目录权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 644 -R /tftpboot</span><br><span class="line">chmod 755 /tftpboot</span><br><span class="line">restorecon -F -R -v /tftpboot</span><br></pre></td></tr></table></figure></li><li><p>建立提供Linux开机的核心目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tftpboot/pxelinux.cfg</span><br><span class="line">mkdir -p /tftpboot/netboot/</span><br><span class="line">restorecon -R -F -v /tftpboot/</span><br></pre></td></tr></table></figure></li><li><p>复制安装光盘文件到FTP分享目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount CentOS-7-x86_64-Minimal-1708.iso /mnt/cdrom</span><br><span class="line">cp -R /mnt/cdrom/* /var/ftp/pub</span><br></pre></td></tr></table></figure></li><li><p>复制PXE启动文件到tftp服务器分享目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/ftp/pub/images/pxeboot</span><br><span class="line">cp vmlinuz initrd.img /tftpboot/netboot/</span><br><span class="line">restorecon -R -F -v /tftpboot/netboot/</span><br></pre></td></tr></table></figure></li><li><p>在FTP服务的目录下建立一个Kickstart文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch /var/ftp/pub/ks.cfg</span><br><span class="line">chmod 644 /var/ftp/pub/ks.cfg</span><br><span class="line">restorecon -R -F -v /var/ftp/pub/</span><br></pre></td></tr></table></figure></li><li><p>设置PXE启动菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /tftpboot/pxelinux.cfg/default</span><br><span class="line"></span><br><span class="line">default menu.c32</span><br><span class="line">prompt 0</span><br><span class="line">timeout 30</span><br><span class="line">MENU TITLE jaydenz.org PXE Menu</span><br><span class="line">LABEL CentOS7_x64</span><br><span class="line">MENU LABEL CentOS 7.4 X86_64</span><br><span class="line">KERNEL /netboot/vmlinuz</span><br><span class="line">APPEND initrd=/netboot/initrd.img inst.repo=ftp://192.168.213.5/pub ks=ftp://192.168.213.5/pub/ks.cfg</span><br></pre></td></tr></table></figure></li><li><p>设定防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=ftp</span><br><span class="line">firewall-cmd --permanent --add-service=tftp</span><br><span class="line">firewall-cmd --permanent --add-service=dhcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>启动各项服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable vsftpd</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl enable tftp</span><br><span class="line">systemctl start tftp</span><br><span class="line">systemctl enable dhcpd</span><br><span class="line">systemctl start dhcpd</span><br></pre></td></tr></table></figure></li></ol><h4 id="Client端配置"><a href="#Client端配置" class="headerlink" title="Client端配置"></a>Client端配置</h4><p>Client端建议将PXE网卡启动顺序放在第二位，也就是硬盘之后，这样当安装程序完成后重启时不会再次进入PXE。</p><h1 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h1><p>Kickstart是redhat开发的开源工具，它可以将操作系统安装步骤记录到一个纯文本文件当中，安装程序通过读取该文件可以实现操作系统自动化安装。</p><p>CentOS 7 Kickstar文件实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">#platform=x86, AMD64, or Intel EM64T</span><br><span class="line">#version=CentOS7</span><br><span class="line">#本配置文件用于自动安装CentOS 7.4 x64位系统</span><br><span class="line"></span><br><span class="line">#####Kickstart安装参数#####</span><br><span class="line">#设置安装界面类型，参数为text | graphical | cmdline，默认为graphical</span><br><span class="line">graphical</span><br><span class="line">#全新安装或是升级</span><br><span class="line">install</span><br><span class="line">#设定安装文件来源</span><br><span class="line">##使用NFS</span><br><span class="line">#nfs --server=192.168.1.128 --dir=/CentOS/CentOS7x64</span><br><span class="line">##使用HTTP/HTTPS、FTP、file</span><br><span class="line">url --url=ftp://192.168.213.1/CentOS/CentOS7x64</span><br><span class="line"></span><br><span class="line">#限制安装程序操作的磁盘</span><br><span class="line">##--drives=sda,hda,...：使安装程序忽略指定的磁盘。</span><br><span class="line">##--only-use：指定安装程序要使用的磁盘列表，忽略其他所有磁盘。</span><br><span class="line">#ignoredisk --only-use=sda</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第一次启动是否运行配置向导，图像化界面建议开启</span><br><span class="line">firstboot --disable</span><br><span class="line">#安装后自动重启。注意，安装后应设置为从先硬盘启动，否则会重复安装</span><br><span class="line">reboot</span><br><span class="line">#设置系统验证信息</span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line"></span><br><span class="line">#####操作系统配置#####</span><br><span class="line">#设定键盘布局</span><br><span class="line">keyboard us</span><br><span class="line">#设定系统语言</span><br><span class="line">lang en_US</span><br><span class="line">#设定系统时区</span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line">#主机名设置</span><br><span class="line">network  --hostname=localhost.localdomain</span><br><span class="line">#配置网络地址获取方式</span><br><span class="line">network  --bootproto=dhcp --onboot=yes</span><br><span class="line"></span><br><span class="line">#####用户和组相关配置#####</span><br><span class="line">#设置root密码，加密密码可以使用openssl生成</span><br><span class="line">rootpw --iscrypted $1$y10oqPAp$qCWLZ7KzL/QgFYlg3C2R10 #采用加密记录</span><br><span class="line">#rootpw --plaintext 123456 #采用明文记录</span><br><span class="line"></span><br><span class="line">#####系统安全相关选项#####</span><br><span class="line">#防火墙配置</span><br><span class="line">##--enabled：启用防火墙</span><br><span class="line">##--disabled：禁用防火墙</span><br><span class="line">##--trust=：允许所有流量通过该防火墙进出指定设备。要列出一个以上的设备，请使用 --trust ens33 --trust ens37</span><br><span class="line">##可以使用以下服务中的一个或多个来替换，从而允许指定的服务通过防火墙。</span><br><span class="line">##--ssh</span><br><span class="line">##--smtp</span><br><span class="line">##--http</span><br><span class="line">##--ftp</span><br><span class="line">##--port=：使用 端口:协议 格式指定允许通过防火墙的端口。例如，如果想允许 IMAP 通过您的防火墙，可以指定 imap:tcp。还可以具体指定端口号码，要允许 UDP 分组在端口 1234 通过防火墙，输入 1234:udp。要指定多个端口，用逗号将它们隔开。</span><br><span class="line"></span><br><span class="line">firewall --disabled</span><br><span class="line"></span><br><span class="line">#SELinux选项</span><br><span class="line">selinux --disabled</span><br><span class="line"></span><br><span class="line">#是否配置X图形界面</span><br><span class="line">skipx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####磁盘于引导选项#####</span><br><span class="line">#bootloader指定指定如何安装引导装载程序</span><br><span class="line">##--location=：指定引导记录的写入位置。</span><br><span class="line">    #mbr：默认参数，具体要看驱动器是MBR还GPT，会自动决定，在大多数情况下不需要指定这个选项。</span><br><span class="line">#partition：在包含内核的分区的第一个扇区中安装引导装载程序。</span><br><span class="line">#none：不安装引导装载程序。</span><br><span class="line">##--append=：指定内核参数。要指定多个参数，使用空格分隔它们。例如：bootloader --location=mbr --append=&quot;hdd=ide-scsi ide=nodma&quot;</span><br><span class="line">bootloader --location=mbr</span><br><span class="line"></span><br><span class="line">#clearpart用于指定如何清除原有分区</span><br><span class="line">##--all：清除所有分区</span><br><span class="line">##--drivers=：用于指定从哪个驱动器清除分区，例子：clearpart --drives=hda,hdb --all，清除主 IDE 控制器中前两个驱动器上所有分区</span><br><span class="line">##--list= - 指定要清理的分区。这个选项覆盖--all和--linux选项，并可跨不同驱动器中使用。例如：clearpart --list=sda2,sda3,sdb1</span><br><span class="line">##--linux - 删除所有 Linux 分区。</span><br><span class="line">##--none（默认）- 不删除任何分区。</span><br><span class="line">clearpart --all     </span><br><span class="line"></span><br><span class="line">#磁盘分区设定</span><br><span class="line">part / --fstype=&quot;xfs&quot; --size=10000</span><br><span class="line">part /boot --fstype=&quot;xfs&quot; --size=200</span><br><span class="line">#part /boot/efi --fstype=efi --size=200 #UEFI引导安装时需要，传统LEGACY引导时可屏蔽此选项</span><br><span class="line">part swap --fstype=&quot;swap&quot; --size=4000</span><br><span class="line"></span><br><span class="line">#如果是要LVM分区，则考虑以下分区</span><br><span class="line">#part /boot --fstype ext4 --size=100</span><br><span class="line">#part swap --fstype=swap --size=2048</span><br><span class="line">#part pv26 --size=100 --grow</span><br><span class="line">#volgroup VG00 --pesize=32768 pv26</span><br><span class="line">#logvol / --fstype ext4 --name=LVroot --vgname=VG00 --size=29984</span><br><span class="line">#logvol /data --fstype ext4 --name=LVdata --vgname=VG00 --size=100 --grow</span><br><span class="line"></span><br><span class="line">#####软件包选项#####</span><br><span class="line">#%packages设定所需要安装的软件包，支持传递参数，--ignoremissing：忽略所有在这个安装源中缺少的软件包、组及环境，</span><br><span class="line">%packages --ignoremissing</span><br><span class="line">#@表示一组软件包，常见安装类型如下:</span><br><span class="line">##@X Window System</span><br><span class="line">##@Desktop</span><br><span class="line">##@Sound and Video </span><br><span class="line">##@network-server</span><br><span class="line">##@performance</span><br><span class="line">##@system-admin-tools</span><br><span class="line">@core</span><br><span class="line">@base</span><br><span class="line">#指定独立的软件包名可以安装单独的软件包，也可以在软件包名称中使用星号（*）作为通配符。</span><br><span class="line">tree</span><br><span class="line">tuned</span><br><span class="line">tuned-utils</span><br><span class="line">ypbind</span><br><span class="line">nfs-utils</span><br><span class="line">vim-enhanced</span><br><span class="line">wget</span><br><span class="line">openssh-server</span><br><span class="line"></span><br><span class="line">#-表示从默认软件包中移除的软件包</span><br><span class="line">-lvm2</span><br><span class="line">-nano</span><br><span class="line">%end #%packages结尾</span><br><span class="line"></span><br><span class="line">#####安装脚本(非必需)#####</span><br><span class="line">%pre     #安装前脚本</span><br><span class="line"></span><br><span class="line">%end     #安装前脚本结尾</span><br><span class="line"></span><br><span class="line">%post    #安装后脚本</span><br><span class="line"></span><br><span class="line">%end     #安装后脚本结尾</span><br></pre></td></tr></table></figure></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>在安装CentOS7时如果一直显示Downloading package metadata或者其他无法获取软件源的问题</p><ol><li>进入入FTP上安装源的repodata目录，打开repomd.xml</li><li>找到xml文件中 location href= 标签指定的文件名</li><li>将repodata目录中一堆字符组成的文件按照xml文件定义的文件名补齐</li><li>重启Client即可进行安装</li></ol><p>首次启动 DHCP 服务器时，如果没有 dhcpd.leases 文件就会失败。如果没有该文件，可使用命令 touch /var/lib/dhcpd/dhcpd.leases 生成该文件。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>PXE官方配置文档：<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/chap-installation-server-setup" target="_blank" rel="noopener">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/chap-installation-server-setup</a></p><p>Kickstart官方语法指导：<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax" target="_blank" rel="noopener">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PXE&quot;&gt;&lt;a href=&quot;#PXE&quot; class=&quot;headerlink&quot; title=&quot;PXE&quot;&gt;&lt;/a&gt;PXE&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="自动化" scheme="http://yoursite.com/categories/Linux/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="http://yoursite.com/2018/05/05/4.Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/05/4.Linux系统启动流程/</id>
    <published>2018-05-05T04:28:01.000Z</published>
    <updated>2018-05-06T02:17:41.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人电脑(PC)的出现极大的普及了计算机的应用，从1980年IBM推出了以Intel的x86构架搭配微软的MS-DOS操作系统的PC以来，现代PC的硬件设备几乎都是由Wintel架构垄断的，不过今天我们并不深入探讨历史，而是介绍一下这种构架的电脑启动的原理。</p><h1 id="PC启动原理"><a href="#PC启动原理" class="headerlink" title="PC启动原理"></a>PC启动原理</h1><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>从按下电源按钮开始，计算机进行加电自检(Power On Self Test ，POST)，POST过后初始化用于启动的硬件（磁盘、键盘控制器等），然后从主板的ROM或Flash芯片中加载基本输入/输出系统(Basic Input/Output System，BIOS)到内存中，进行初始化，随后从CMOS中读取用户自定义的设置，这时候根据设置信息，BIOS通过启动顺序(BootSequence)列表查找对应设备上的启动文件。</p><h3 id="MBR格式磁盘"><a href="#MBR格式磁盘" class="headerlink" title="MBR格式磁盘"></a>MBR格式磁盘</h3><p>在使用MBR格式的磁盘时，这种格式的磁盘第一个扇区保存有主引导记录(Master Boot Becord，MBR)，这个记录有512字节大小，如果最后两个字节是0x55和0xAA，表明这个设备可以用于启动，那么它将接管BIOS传递的控制权，否则，BIOS将查找下一个设备。</p><h4 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h4><p>主引导记录由三部分组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第1-446字节：调用操作系统的机器码</span><br><span class="line">第447-510字节：分区表（Partition table）</span><br><span class="line">第511-512字节：主引导记录签名（0x55和0xAA）</span><br></pre></td></tr></table></figure></p><p>由于分区表的长度只有64个字节，一个分区需要占用16个字节，所以MBR格式硬盘最多只能存在四个主分区。MBR格式磁盘的弊端不仅如此：由于主分区只有16个字节，它又由6个部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第1个字节：如果为0x80，就表示该主分区是激活分区</span><br><span class="line">第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）</span><br><span class="line">第5个字节：主分区类型</span><br><span class="line">第6-8个字节：主分区最后一个扇区的物理位置</span><br><span class="line">第9-12字节：该主分区第一个扇区的逻辑地址</span><br><span class="line">第13-16字节：主分区的扇区总数，决定了这个主分区的长度。</span><br></pre></td></tr></table></figure></p><p>扇区总数为最多不超过2的32次方，如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。为了解决这些问题，人们发明了GPT格式的硬盘。</p><p>继续前面的话题，当BIOS在存储设备找到MBR并且MBR存在启动信息时，这时又会遇到三种情况</p><ol><li>卷引导记录<br>四个主分区里只有一个是激活的，那么计算机会读取激活分区的第一个扇区，叫做卷引导记录(Volume Boot Record，VBR)，它会告诉计算机操作系统所在分区的位置，然后计算机开始加载操作系统</li><li>扩展分区和逻辑分区<br>由于MBR磁盘只能存在四个主分区，但是在硬盘越来越大的今天是远远不够用的，所以，人们把其中一个主分区定义成扩展分区(Extended Partition)，在这个分区中又可以划分出多个逻辑分区(Logical Partition)，理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和MBR结构类似的扩展引导记录，如果操作系统安装在扩展分区，计算机会先读取扩展分区的第一个扇区中的扩展引导记录，但是一般很少使用这种方式启动操作系统。</li><li>Bootloader<br>当使用启动管理器时，计算机读取主引导记录前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的启动管理器(Bootloader)，由用户选择启动哪一个操作系统。这也是当今操作系统启动的主流方式。</li></ol><p>在Windows系统中</p><ul><li>Windows NT开始为NTLDR</li><li>Winsows Vista开始为Windows Boot Manager</li></ul><p>在Linux系统中</p><ul><li>CentOS 6为grub legacy</li><li>CentOS 7为grub2</li></ul><hr><h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>随着计算机技术的不断进步，老旧的BIOS已经不能适应现在的要求，于是统一可扩展固件接口(Unified Extensible Firmware Interface，UEFI)技术出现了。</p><p>与BIOS相比，UEFI使用模块化理念，它可以加载ESP分区中的EFI应用程序和EFI驱动程序，支持安全启动、GUI等新功能，这些取决于PC制造商是否添加，它还能实现BIOS的兼容模式。只需要把操作系统的引导程序做成一个EFI应用程序就可以使用UEFI加载引导了，如果存在多个操作系统，只需要在UEFI引导界面选择相应的程序就行了。<br>UEFI的启动流程<br>首先系统开机，然后进行自检(Power On Self Test，POST)，随后UEFI 固件被加载，并由它初始化启动要用的硬件。随后启动UEFI引导管理器，它将通过NVRAM中定义的配置决定如何加载UEFI驱动和UEFI可执行文件。已启动的UEFI应用还可以启动其他应用比如bootloader或者启动内核及initramfs，我们只要把操作系统的bootloader做成一个EFI可执行文件，放入EFI分区对应的目录就可以使用UEFI读取启动了。</p><h3 id="GPT格式磁盘"><a href="#GPT格式磁盘" class="headerlink" title="GPT格式磁盘"></a>GPT格式磁盘</h3><p>全局唯一标识分区表(GUID Partition Table，GPT)，与MBR最大4个分区表项的限制相比，GPT对分区数量没有限制，其分区数量只受操作系统限制，GPT可管理硬盘大小达到了18EB。只有基于UEFI平台的主板才支持GPT分区引导启动。</p><hr><h1 id="Linux系统启动流程"><a href="#Linux系统启动流程" class="headerlink" title="Linux系统启动流程"></a>Linux系统启动流程</h1><h2 id="1-内核的引导"><a href="#1-内核的引导" class="headerlink" title="1.内核的引导"></a>1.内核的引导</h2><p>存储设备上的Bootloader接过BIOS的控制权后进行Linux的内核引导，这时根文件系统并未挂载，而内核要读取文件系统就必须要挂载根文件系统，但此时并没有文件系统能提供挂载点，为了解决这个问题内核就先读取存储介质中的初始RAM磁盘(Initialized RAM Disk，initrd)并将其加载到内存作为一个临时的根目录，加载一部分驱动，最重要的是用来挂载真正的根文件系统(这时是以只读方式)，然后切换到真正的根文件系统，完成初始化任务，最后内核会运行第一个程序/sbin/init并将系统控制权交给它。</p><h2 id="2-启动初始化进程"><a href="#2-启动初始化进程" class="headerlink" title="2.启动初始化进程"></a>2.启动初始化进程</h2><p>Linux的init程序经过了好几个版本，以CentOS为例</p><table><thead><tr><th>系统版本</th><th>init程序</th></tr></thead><tbody><tr><td>CentOS 5及以前</td><td>SysV，配置文件： /etc/inittab</td></tr><tr><td>CentOS 6</td><td>Upstart，配置文件： /etc/inittab, /etc/init/*.conf</td></tr><tr><td>CentOS 7</td><td>Systemd，配置文件： /usr/lib/systemd/system、 /etc/systemd/system</td></tr></tbody></table><p>在使用SysV的系统上,内核文件加载之后，就开始运行第一个程序/sbin/init，它负责初始化系统环境，他的pid为1，其他所有进程都由它衍生，都是他的子进程。<br>在采用systemd的系统上，运行的第一个程序为/usr/lib/systemd/systemd，它的的pid同样为1，也是所有进程的父进程。</p><h2 id="3-设置运行级别"><a href="#3-设置运行级别" class="headerlink" title="3.设置运行级别"></a>3.设置运行级别</h2><p>运行级别用于设定Linux操作系统不同的运行模式，运行级别控制Linux系统通过init程序为不同场合分配不同的开机启动程序。</p><p>Linux系统有7个运行级别(runlevel)：</p><table><thead><tr><th>运行级别</th><th>说明  </th></tr></thead><tbody><tr><td>runlevel 0</td><td>系统停机、关机，系统默认运行级别不能设为0，否则不能正常启动</td></tr><tr><td>runlevel 1</td><td>单用户状态，root权限，用于系统维护，禁止远程登陆，无网络连接</td></tr><tr><td>runlevel 2</td><td>多用户状态，无网络连接，不运行守护进程，无NFS</td></tr><tr><td>runlevel 3</td><td>完全的多用户状态，有NFS，登陆后进入控制台命令行模式</td></tr><tr><td>runlevel 4</td><td>系统未使用，保留</td></tr><tr><td>runlevel 5</td><td>多用户，X11控制台，登陆后进入图形GUI模式</td></tr><tr><td>runlevel 6</td><td>系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</td></tr></tbody></table><p>init程序读取/etc/inittab定义的运行级别来进行系统初始化。</p><p>在systemd中runlevel已被target取代，systemd会读取/etc/systemd/system/default.target来决定启动到什么样的target(sysv中称为runlevel)，这是一个符号链接，指向/usr/lib/systemd/system/下相应的target，由于可以实现并行启动，systemd没有严格的启动顺序。在CLI环境default.target指向/lib/systemd/system/multi-user.target，systemd通过读取target文件进行下一步操作，比如运行/usr/lib/systemd/system/sysinit.target开始系统初始化，这些都依赖于相应的target文件中的配置。</p><h2 id="4-系统初始化"><a href="#4-系统初始化" class="headerlink" title="4.系统初始化"></a>4.系统初始化</h2><p>当设置好了runlevel之后，init程序会首先执行/etc/rc.d/rc.sysinit脚本，它是每个runlevel都要执行的重要脚本，它主要进行以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.设置主机名称；</span><br><span class="line">2.设置启动的欢迎信息；</span><br><span class="line">3.激活udev和SELinux</span><br><span class="line">4.挂载/etc/fstab文件中定义的所有有效文件系统；</span><br><span class="line">5.激活各个swap设备；</span><br><span class="line">6.检测rootfs，并且以读写的方式重新挂载rootfs；</span><br><span class="line">7.设置系统时间；</span><br><span class="line">8.根据/etc/sysctl.conf文件设置内核参数；</span><br><span class="line">9.激活lvm和软RAID等高级逻辑设备；</span><br><span class="line">10.加载额外的设备的驱动程序；</span><br><span class="line">11.完成清理工作；</span><br></pre></td></tr></table></figure></p><p>然后init程序根据相应的级别加载对应配置的程序，所有由rc脚本关闭或启动的链接文件的源文件都存在于/etc/rc.d/init.d，通过链接的方式放入不同的runlevel文件夹。比如当引导至运行级别 5 时，init 程序会在 /etc/rc.d/rc5.d/ 目录中查看并确定要启动和停止的进程。当init程序启动完对应的程序与守护进程后，这是系统环境基本已经搭建好了。</p><p>在systemd中，/usr/lib/systemd/system/sysinit.target、/usr/lib/systemd/system/basic.target等target会根据对应的依赖关系启动，执行相应的系统初始化任务。</p><h2 id="5-用户登陆"><a href="#5-用户登陆" class="headerlink" title="5.用户登陆"></a>5.用户登陆</h2><p>用户可以通过三种方式登陆Linux</p><ul><li>CLI登陆</li><li>SSH登陆</li><li>GUI登陆</li></ul><p>这几种登陆方式会读取不同的配置文件，在Bash Shell相关博文会做详细介绍。</p><p>用户登陆系统后，开机过程就算完成了。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简化的Linux系统启动流程</p><p>BIOS + MBR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST --&gt; BIOS --&gt; MBR --&gt; Bootloader --&gt; kernel + ramdisk --&gt; rootfs(read-only) --&gt; /sbin/init(systemd) --&gt; login</span><br></pre></td></tr></table></figure></p><p>UEFI + GPT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST --&gt; UEFI --&gt; EFI Application(Bootloader) --&gt; kernel + ramdisk --&gt; rootfs(read-only) --&gt; /sbin/init(systemd) --&gt; login</span><br></pre></td></tr></table></figure></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>Overview of systemd for RHEL 7：<a href="https://access.redhat.com/articles/754933" target="_blank" rel="noopener">https://access.redhat.com/articles/754933</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;个人电脑(PC)的出现极大的普及了计算机的应用，从1980年IBM推出了以Intel的x86构架搭配微软的MS-DOS操作系统的PC以来，现
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>解决文件被占用无法删除</title>
    <link href="http://yoursite.com/2018/05/02/3.%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2018/05/02/3.解决文件被占用无法删除/</id>
    <published>2018-05-02T04:28:01.000Z</published>
    <updated>2018-05-07T13:31:53.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows系统查看文件被哪个进程占用"><a href="#Windows系统查看文件被哪个进程占用" class="headerlink" title="Windows系统查看文件被哪个进程占用"></a>Windows系统查看文件被哪个进程占用</h1><ol><li>有时候在使用电脑时想要删除一个文件或者文件夹，结构遇到这样的情况:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx3.sinaimg.cn/mw690/a90f05d0gy1fqznr3wbz9j20ch07a3ym.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>这时候只要打开任务管理器，选择性能标签，点击底部的打开资源监视器<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx3.sinaimg.cn/mw690/a90f05d0gy1fqznr8i4gyj20kk0jxwfr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>然后选择CPU标签，在下面的关联的句柄搜索删不掉的文件夹名或文件名，就能找出占用的进程，结束掉它就能删除文件。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/mw690/a90f05d0gy1fqznrdwz4oj20lv0gjwfi.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><h1 id="Linux查看文件被哪个进程占用"><a href="#Linux查看文件被哪个进程占用" class="headerlink" title="Linux查看文件被哪个进程占用"></a>Linux查看文件被哪个进程占用</h1><p>Linux使用lsof命令<br><code>lsof /PATH/TO/SOMEFILE     #查看某文件被哪个程序占用</code><br>找到之后使用ps命令找出pid结束进程即可。<br>lsof命令还可以实现其他很多功能，简单举几个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof  -u USERNAME     #查看某用户打开的文件信息</span><br><span class="line">lsof -c mysql         #列出某命令打开的文件</span><br><span class="line">lsof  -i tcp          #列出所有tcp网络连接信息</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows系统查看文件被哪个进程占用&quot;&gt;&lt;a href=&quot;#Windows系统查看文件被哪个进程占用&quot; class=&quot;headerlink&quot; title=&quot;Windows系统查看文件被哪个进程占用&quot;&gt;&lt;/a&gt;Windows系统查看文件被哪个进程占用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Windows" scheme="http://yoursite.com/categories/Linux/Windows/"/>
    
    
      <category term="解决问题" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>常见开源协议介绍</title>
    <link href="http://yoursite.com/2018/05/01/2.%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/05/01/2.常见开源协议介绍/</id>
    <published>2018-05-01T04:28:01.000Z</published>
    <updated>2018-05-04T14:40:38.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;自理查德·斯托曼于1983年发起GNU计划时起，开源的理念逐渐在互联网传播。开源运动后来分化出了开源软件和自由软件两个说法，自由软件根据自由软件基金会的定义是指一类<strong>可以不受限制地自由使用、复制、研究、修改和分发的，尊重用户自由的软件</strong>，而开源软件是指一类<strong>源代码可以任意获取的计算机软件，这种软件的版权持有人在软件协议的规定之下保留一部分权利并允许用户学习、修改、增进提高这款软件的质量</strong>，而对它们进行约束的就是开源协议。目前互联网存在诸多开源协议，每种协议的要求各不相同，下面介绍一下几个常见的开源协议。</p><h1 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h1><p>&emsp;&emsp;GNU General Pubilc Licence(GPL)是一种广泛使用的开源软件许可证，可以保证终端用户得自由运行，学习，共享和修改软件，目前已经发布到了第三版。GPL协议最主要的几个原则：</p><ol><li>可自由复制<br>你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。</li><li>可自由分发<br>在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来分发。</li><li>可以用来盈利<br>你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。</li><li>可自由修改<br>可以自由添加或删除某个功能，或在别的项目中使用部分代码。唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。</li></ol><p>简单的讲，<strong>选择GPL协议，任何衍生代码都必须开源，并且以相同的许可条款分发</strong>，这就是为什么我们能用到各式各样的免费Linux发行版的原因。</p><h1 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h1><p>&emsp;&emsp;LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生自GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h1 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h1><p>&emsp;&emsp;BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ol><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ol><p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h1 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h1><p>&emsp;&emsp;MIT 协议可能是几大开源协议中最宽松的一个，核心条款是：<br>该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示。这意味着：</p><ol><li>你可以自由使用，复制，修改，可以用于自己的项目。</li><li>可以免费分发或用来盈利。</li><li>唯一的限制是必须包含许可声明。</li></ol><h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>&emsp;&emsp;Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布作为开源或商业软件。需要满足的条件也和BSD类似：</p><ol><li>需要给使用代码的用户一份Apache Licence</li><li>如果你修改了代码，需要在被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li><li>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="开源协议关系图"><a href="#开源协议关系图" class="headerlink" title="开源协议关系图"></a>开源协议关系图</h2>阮一峰老师有一张简洁明了的图来解释上述几种开源协议的关系<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/mw690/a90f05d0gy1fqznriisfij20j60bo0tl.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>还有一张来自GcsSloop dalao的图片<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/mw690/a90f05d0gy1fqznrme5ucj20le09uac5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="五大开源协议官方网站"><a href="#五大开源协议官方网站" class="headerlink" title="五大开源协议官方网站"></a>五大开源协议官方网站</h2>BSD: <a href="https://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BSD_licenses</a><br>MIT: <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">https://opensource.org/licenses/MIT</a><br>Apache2.0: <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">http://www.apache.org/licenses/LICENSE-2.0</a><br>GNU GPL: <a href="https://www.gnu.org/licenses/gpl-howto.html" target="_blank" rel="noopener">https://www.gnu.org/licenses/gpl-howto.html</a><br>LGPL: <a href="http://opensource.org/licenses/lgpl-license" target="_blank" rel="noopener">http://opensource.org/licenses/lgpl-license</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;自理查德·斯托曼于1983年发起GNU计划时起，开源的理念逐渐在互联网传播。开源运动后来分化出了开源软件和自由软件两
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用说明</title>
    <link href="http://yoursite.com/2018/04/06/1.Hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/04/06/1.Hexo使用说明/</id>
    <published>2018-04-06T04:28:01.000Z</published>
    <updated>2018-05-19T00:29:18.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于使用，再加上可以部署到Github上面，成为很多程序员首选的个人博客框架。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Hexo依赖于Node.js，下载对应版本的Node.js运行环境安装<br>检查Node.js是否安装成功<br>    <code>node -v</code><br>检测npm是否安装成功<br>    <code>npm -v</code><br>安装Hexo<br>    <code>npm install -g hexo-cli</code><br>初始化博客<br>    进入到自定义的空目录，输入<br>    <code>hexo init</code></p><h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><ol><li>登陆Github并新建一个公开仓库，仓库名应该为：用户名.github.io </li><li>安装Git</li><li><p>设置Git，打开命令行，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成ssh密钥<br><code>ssk-keygen -t rsa</code></p></li><li>进入用户目录的.ssh文件夹中查看id_rsa.pub文件，将其内容复制到Github 博客项目的Settings页面的Deploy keys页面</li></ol><h1 id="Hexo命令常见用法"><a href="#Hexo命令常见用法" class="headerlink" title="Hexo命令常见用法"></a>Hexo命令常见用法</h1><h2 id="编写博文"><a href="#编写博文" class="headerlink" title="编写博文"></a>编写博文</h2><p>在命令行输入<br>    <code>hexo n &quot;博客名字&quot;</code><br>在blog根目录下的source文件夹中的_post文件夹中多了一个博客名字.md文件，然后使用Markdown编辑器进行编辑即可</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>在命令行输入<br>    <code>hexo server</code><br>使用浏览器访问localhost:4000 即可预览博文效果。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo -g                      #升级</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;  #新建文章</span><br><span class="line">hexo g == hexo generate                   #生成</span><br><span class="line">hexo s == hexo server                     #启动服务预览，Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s                            #静态模式</span><br><span class="line">hexo server -p 5000                       #更改端口</span><br><span class="line">hexo server -i 192.168.1.1                #自定义IP</span><br><span class="line">hexo d == hexo deploy                     #部署</span><br><span class="line">hexo clean                                #清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>写好博文并且样式无误后，在命令输入<br>    <code>hexo g</code><br>    <code>hexo d</code><br>生成、部署网页。随后可以在浏览器中输入域名浏览。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="如何创建Tags和Categories"><a href="#如何创建Tags和Categories" class="headerlink" title="如何创建Tags和Categories"></a>如何创建Tags和Categories</h2><ol><li>首先创建新的页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>在source文件夹下分别修改相应的index.md文件，将页面的类型设置为 categories | tags<br>categories/index.md<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-4-30 11:59:10</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><p>tags/index.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-4-30 11:59:10</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><ol start="3"><li>修改scaffolds文件夹下面的文件<br>scaffolds/draft.md<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>scaffolds/post.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="如何引用图片"><a href="#如何引用图片" class="headerlink" title="如何引用图片"></a>如何引用图片</h2><ol><li>本地绝对引用<br>文章中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#图片路径</span><br><span class="line">source/images/image.jpg</span><br><span class="line">#Markdown引用语法</span><br><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure></li></ol><p>这样图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><ol start="2"><li>本地相对引用<br>配置_config.yml<br><code>post_asset_folder: true</code><br>执行命令<br><code>$ hexo new post_name</code><br>在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#图片路径</span><br><span class="line">_posts/post_name/image.jpg</span><br><span class="line">#Markdown引用语法</span><br><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure></li></ol><p>但是图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#图片路径</span><br><span class="line">_posts/post_name/image.jpg</span><br><span class="line">#Markdown引用语法</span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>互联网引用<br>申请了CDN或者图片床之后，直接将链接添加到文章即可<h2 id="Deployer-not-found-git"><a href="#Deployer-not-found-git" class="headerlink" title="Deployer not found: git"></a>Deployer not found: git</h2>在终端执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ol><p>然后继续执行hexo deploye指令进行部署。</p><h2 id="调整indigo主题适配宽屏"><a href="#调整indigo主题适配宽屏" class="headerlink" title="调整indigo主题适配宽屏"></a>调整indigo主题适配宽屏</h2><p>修改hexo-theme-indigo/source/css/_partial/variable.less</p><p>把<code>@contentWidth: 960px;</code>改成<code>@contentWidth: 90%;</code></p><p>修改主题config文件<code>cdn: false</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Hexo是一款基于Node.js的静态博客框架，依赖少易于使用，再加上可以部署到Github上面，成为很多程序员首选的个人博客框架。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
